## ---- Partition 확인.
\d+ sales

SELECT partitiontablename, partitionrangestart, partitionrangeend
FROM pg_partitions
WHERE tablename = 'sales' AND schemaname = 'public';

## ---- 함수 생성
CREATE OR REPLACE FUNCTION generate_random_string_md5(length INT)
RETURNS TEXT AS $$
BEGIN
    RETURN SUBSTRING(MD5(RANDOM()::text || CLOCK_TIMESTAMP()::text), 1, length);
END;
$$ LANGUAGE plpgsql VOLATILE; 

SELECT generate_random_string_md5(10);

## 테이블 생성 예시1
CREATE TABLE test_table (
    col1 character varying(82),
    col2 character varying(10),
    col3 character varying(82),
    col4 character varying(50),
    start_datetime integer,
    gploaded_time timestamp without time zone
)
WITH (appendonly=true) DISTRIBUTED BY (col1);

INSERT INTO test_table values('00001','col2col2','col3col3', 'col4col4col4col4',2019384,now());
INSERT INTO test_table values('00002','col2col2','col3col3', 'col4col4col4col4',2019384,now());
INSERT INTO test_table values('00003','col2col2','col3col3', 'col4col4col4col4',2019384,now());
INSERT INTO test_table values('00004','col2col2','col3col3', 'col4col4col4col4',2019384,now());
INSERT INTO test_table values(generate_random_string_md5(10),'col2col2','col3col3', 'col4col4col4col4',2019384,now());

## 테이블 생성 예시2
CREATE TABLE rtitrans (
    imsi character varying(82),
    subscriber_mccmnc character varying(10),
    msisdn character varying(82),
    imei character varying(50),
    called_digits character varying(50),
    start_datetime integer,
    end_datetime integer,
    first_cell_lac integer,
    first_cell_idsac integer,
    current_cell_lac integer,
    current_cell_idsac integer,
    dr_type integer,
    status character varying(50),
    ingest_time bigint,
    processed_time bigint,
    export_time bigint,
    extra_col text,
    gploaded_time timestamp without time zone
)
WITH (appendonly=true) DISTRIBUTED BY (imsi);CREATE TABLE sales (
    sale_id     bigint,
    sale_date   date,
    region      text,
    amount      numeric
)
DISTRIBUTED BY (sale_id)  -- 데이터 분산은 분산키로 처리
PARTITION BY RANGE (sale_date) -- 파티셔닝은 파티션키로 처리
(
    PARTITION sales_2025_q1 START ('2025-01-01'::date) INCLUSIVE
                          END ('2025-04-01'::date) EXCLUSIVE,
    PARTITION sales_2025_q2 START ('2025-04-01'::date) INCLUSIVE
                          END ('2025-07-01'::date) EXCLUSIVE,
    PARTITION sales_2025_q3 START ('2025-07-01'::date) INCLUSIVE
                          END ('2025-10-01'::date) EXCLUSIVE,
    PARTITION sales_2025_q4 START ('2025-10-01'::date) INCLUSIVE
                          END ('2026-01-01'::date) EXCLUSIVE,
    -- 정의된 범위 밖의 데이터가 들어갈 기본 파티션 (필수 권장)
    DEFAULT PARTITION others
);

## 테이블 파티션 추가 
ALTER TABLE sales ADD PARTITION sales_2026_q1
    START ('2026-01-01'::date) INCLUSIVE
    END ('2026-02-01'::date) EXCLUSIVE;

## 테이블 파티션 삭제
ALTER TABLE sales DROP PARTITION sales_2025_q1;

## DEFAULT 파티션 관리
ALTER TABLE sales SPLIT DEFAULT PARTITION
    START ('2026-01-01'::date) INCLUSIVE
    END ('2026-02-01'::date) EXCLUSIVE
    INTO (PARTITION sales_2026_q1, DEFAULT PARTITION);

## 예시: DEFAULT 파티션에서 2024년 1월 분량을 쪼개서 새로운 파티션으로 생성
ALTER TABLE sales 
SPLIT DEFAULT PARTITION 
    START (date '2024-01-01') INCLUSIVE 
    END (date '2024-02-01') EXCLUSIVE
    INTO (PARTITION p202401, DEFAULT PARTITION);

## procudure/function으로 신규 파티션 추가 가능
## (개념적인 예시) 다음 달 파티션 추가 함수
CREATE OR REPLACE FUNCTION add_next_month_partition() RETURNS void AS $$
DECLARE
    next_month_start date;
    next_month_end date;
    partition_name text;
BEGIN
    -- 다음 달 1일 계산
    next_month_start := date_trunc('month', current_date + interval '1 month');
    -- 다다음 달 1일 계산
    next_month_end := date_trunc('month', current_date + interval '2 months');
    
    -- 동적 SQL 실행 (DEFAULT 파티션 없다는 가정)
    EXECUTE format('ALTER TABLE sales ADD PARTITION START (%L) INCLUSIVE END (%L) EXCLUSIVE', 
                   next_month_start, next_month_end);
END;
$$ LANGUAGE plpgsql;



